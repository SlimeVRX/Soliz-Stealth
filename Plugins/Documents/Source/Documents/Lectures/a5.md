### Tài liệu Hướng dẫn Triển khai Lớp PlayerCharacter cho Cơ chế Bụi Cỏ Multiplayer (Unreal Engine C++)

Tài liệu này cung cấp hướng dẫn chi tiết từng bước bằng C++ để sửa đổi lớp `APlayerCharacter` hoặc tạo một lớp con tùy chỉnh, tích hợp nó vào cơ chế bụi cỏ multiplayer dựa trên các tài liệu thiết kế trước đó. Chúng ta sẽ tập trung vào việc thiết lập va chạm trên Character để tương tác với `ABushActor`, phát hiện sự kiện đi vào/ra, báo cáo các sự kiện này lên Server bằng RPCs, và hiểu cách Client sẽ nhận lệnh cập nhật hiển thị.

#### 1. Giới thiệu và Mục tiêu

Trong hệ thống bụi cỏ multiplayer, `APlayerCharacter` đóng vai trò trung tâm là đối tượng mà người chơi điều khiển và là thực thể vật lý tương tác với thế giới game. Để cơ chế bụi cỏ hoạt động, Character cần có khả năng phát hiện khi nó đi vào hoặc đi ra khỏi thể tích va chạm của một `ABushActor`.

*   Vai trò của APlayerCharacter:
    *   Là đại diện của người chơi trong thế giới game, có vị trí và hình dạng vật lý (thường thông qua một Capsule Component).
    *   Cần phát hiện va chạm (overlap) với các Actor thuộc loại bụi cỏ (`ABushActor`).
    *   Trên máy của người chơi điều khiển (Client sở hữu), Character cần báo cáo sự kiện va chạm này (đi vào/ra bụi cỏ) cho Server.
    *   Trên tất cả các máy Client, Character cần có khả năng bị ẩn hoặc hiện dựa trên lệnh từ Server.
*   Mục tiêu của việc sửa đổi: Trang bị cho lớp `APlayerCharacter` các khả năng cần thiết để trở thành một "cảm biến" va chạm bụi cỏ phía Client và một "thực thể nhận lệnh" hiển thị từ Server, phù hợp với kiến trúc Server authoritative đã thiết kế.

Việc này tiếp nối bước đã triển khai `ABushActor`, đóng vai trò là "vùng" hoặc "trigger" cho cơ chế bụi cỏ. `ABushActor` có thể phát hiện va chạm, nhưng chính Character mới là đối tượng chủ động báo cáo hành động di chuyển của người chơi vào/ra các vùng này.

#### 2. Thiết lập Thành phần Va chạm trên PlayerCharacter

Lớp `ACharacter` mặc định đi kèm với một `UCapsuleComponent` đóng vai trò là thành phần va chạm gốc và đại diện cho hình dạng vật lý của Character. Chúng ta cần đảm bảo `UCapsuleComponent` này được cấu hình đúng để tương tác (overlap) với `ABushActor`.

*   Kiểm tra/Cấu hình `UCapsuleComponent`:
    *   Mở tệp header (.h) của lớp `APlayerCharacter` tùy chỉnh của bạn (ví dụ: `ACustomPlayerCharacter`).
    *   Character base class đã khai báo `CapsuleComponent` là `RootComponent`.
    *   Trong constructor (.cpp), chúng ta cần cấu hình va chạm cho `GetCapsuleComponent()`.

*   Các thiết lập Collision Presets hoặc kênh va chạm cần thiết:
    *   `Object Type`: `UCapsuleComponent` của Character thường có `Object Type` là `ECC_Pawn`. Đây là Object Type mặc định cho các Character/Pawn và nó phù hợp với cấu hình của `ABushActor` (đã cấu hình Overlap với `ECC_Pawn`).
    *   `Collision Enabled`: Phải cho phép Query (ví dụ: `ECollisionEnabled::QueryOnly` hoặc `ECollisionEnabled::QueryAndPhysics`) để có thể phát hiện overlap. `QueryAndPhysics` là phổ biến cho Character vì nó cũng cần chặn vật lý.
    *   `Response to Channel`: Quan trọng nhất là cấu hình phản ứng (`Response`) của Capsule Component với kênh va chạm mà `ABushActor` sử dụng. Trong tài liệu `ABushActor`, chúng ta đã cấu hình `BushOverlapVolume` có `Object Type` là `ECC_WorldDynamic` và phản ứng `ECR_Overlap` với kênh `ECC_Pawn`. Do đó, CapsuleComponent của Character (có `Object Type` là `ECC_Pawn`) cần cấu hình phản ứng `ECR_Overlap` với kênh `ECC_WorldDynamic`.

Dưới đây là cấu hình trong constructor của `ACustomPlayerCharacter.cpp`:

```cpp
// Trong constructor của ACustomPlayerCharacter::ACustomPlayerCharacter()
{
    // ... các thiết lập khác của Character ...

    // Lấy con trỏ tới Capsule Component mặc định của Character
    // UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Character", meta = (AllowPrivateAccess = "true"))
    // class UCapsuleComponent* CapsuleComponent; // Khai báo trong ACharacter.h

    // Đảm bảo va chạm được bật
    GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);

    // Đảm bảo Object Type là Pawn (thường là mặc định cho Character)
    GetCapsuleComponent()->SetCollisionObjectType(ECollisionChannel::ECC_Pawn);

    // Đặt phản ứng mặc định là Ignore cho tất cả các kênh khác (tùy game)
    // GetCapsuleComponent()->SetCollisionResponseToAllChannels(ECR_Ignore); // Cẩn thận khi thay đổi mặc định của Character

    // Cấu hình phản ứng Overlap với kênh của ABushActor (ECC_WorldDynamic như trong ABushActor)
    // Đây là thiết lập quan trọng để phát hiện va chạm với BushActor
    GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldDynamic, ECR_Overlap);

    // Đảm bảo tạo sự kiện va chạm (overlap events) được bật
    GetCapsuleComponent()->SetGenerateOverlapEvents(true);

    // ... các thiết lập khác ...
}
```

Bảng tóm tắt cấu hình va chạm cho Character Capsule:

| Thuộc tính             | Giá trị C++                               | Ý nghĩa                                                                 |
| :--------------------- | :---------------------------------------- | :---------------------------------------------------------------------- |
| Collision Enabled      | `ECollisionEnabled::QueryAndPhysics`      | Cho phép truy vấn (overlap, trace) và chặn vật lý.                      |
| Collision Object Type  | `ECollisionChannel::ECC_Pawn`             | Phân loại component này là một Pawn/Character.                          |
| Response to `ECC_WorldDynamic` | `ECR_Overlap`                             | Tạo sự kiện overlap khi gặp đối tượng thuộc loại WorldDynamic (BushActor). |
| Generate Overlap Events| `true`                                    | Bật việc gửi các sự kiện `OnComponentBeginOverlap`/`EndOverlap`.        |

```svg
<svg width="600" height="250" xmlns="http://www.w3.org/2000/svg">
  <style>
    .node {
      stroke: #333;
      stroke-width: 1.5;
      font-family: Arial;
      font-size: 14px;
    }
    .actor { fill: #f9f9f9; }
    .component { fill: #ADD8E6; } /* Light Blue */
    .config { fill: #FFFF99; } /* Light Yellow */
    .edge { stroke: #333; stroke-width="1.5"; marker-end="url(#arrowhead)"; }
    .label { font-size: 12px; fill: #555; text-anchor: middle; }
     #arrowhead path { fill: #333; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" />
    </marker>
  </defs>

  <!-- Nodes -->
  <rect x="50" y="50" width="200" height="50" rx="5" ry="5" class="actor"/>
  <text x="150" y="80" class="node" text-anchor="middle">ACustomPlayerCharacter</text>

  <rect x="350" y="50" width="200" height="50" rx="5" ry="5" class="actor"/>
  <text x="450" y="80" class="node" text-anchor="middle">ABushActor</text>


  <rect x="75" y="150" width="150" height="50" rx="5" ry="5" class="component"/>
  <text x="150" y="180" class="node" text-anchor="middle">CapsuleComponent</text>
  <text x="150" y="200" class="label" text-anchor="middle">Object Type: ECC_Pawn</text>


  <rect x="375" y="150" width="150" height="50" rx="5" ry="5" class="component"/>
  <text x="450" y="180" class="node" text-anchor="middle">BushOverlapVolume</text>
  <text x="450" y="200" class="label" text-anchor="middle">Object Type: ECC_WorldDynamic</text>

  <!-- Edge -->
  <path d="M150 100 V 150" class="edge"/>
   <path d="M450 100 V 150" class="edge"/>

   <path d="M225 175 H 375" class="edge"/>
   <text x="300" y="165" class="label" text-anchor="middle">Overlap</text>
   <text x="300" y="185" class="label" text-anchor="middle">(ECC_Pawn vs ECC_WorldDynamic)</text>


</svg>
```
*Sơ đồ tương tác va chạm giữa CapsuleComponent của Character và BushOverlapVolume của BushActor.*

#### 3. Phát hiện Va chạm với ABushActor

Sau khi cấu hình va chạm, CapsuleComponent của Character sẽ bắt đầu tạo ra các sự kiện overlap khi tương tác với `ABushActor`. Chúng ta cần đăng ký các hàm xử lý cho các sự kiện này.

*   Cách đăng ký (bind) sự kiện: Sử dụng `AddDynamic` trong constructor của Character, tương tự như cách đã làm với `ABushActor`. Sự kiện này xảy ra trên CapsuleComponent của Character.
    ```cpp
    // Trong constructor của ACustomPlayerCharacter::ACustomPlayerCharacter()
    {
        // ... cấu hình va chạm ...

        // Bind các hàm xử lý sự kiện va chạm trên CapsuleComponent
        GetCapsuleComponent()->OnComponentBeginOverlap.AddDynamic(this, &ACustomPlayerCharacter::OnCharacterBeginOverlap);
        GetCapsuleComponent()->OnComponentEndOverlap.AddDynamic(this, &ACustomPlayerCharacter::OnCharacterEndOverlap);

        // ... các thiết lập khác ...
    }
    ```
    *   Lưu ý: Tên hàm xử lý (`OnCharacterBeginOverlap`, `OnCharacterEndOverlap`) là tùy chọn, nhưng cần có signature (kiểu trả về và tham số) phù hợp với delegate `OnComponentBeginOverlap`/`OnComponentEndOverlap`. Hàm cũng cần là `UFUNCTION()`.

*   Triển khai các hàm xử lý sự kiện: Trong các hàm này, chúng ta sẽ kiểm tra xem Actor mà Character overlap cùng có phải là một `ABushActor` hay không.

    ```cpp
    // Khai báo trong ACustomPlayerCharacter.h:
    UFUNCTION()
    void OnCharacterBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

    UFUNCTION()
    void OnCharacterEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

    // Triển khai trong ACustomPlayerCharacter.cpp:
    void ACustomPlayerCharacter::OnCharacterBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
    {
        // Kiểm tra xem Actor va chạm có phải là ABushActor không
        ABushActor* Bush = Cast<ABushActor>(OtherActor);
        if (Bush)
        {
            // Phát hiện va chạm với ABushActor!
            // TODO: Logic xử lý sự kiện Player đi vào bụi cỏ
             UE_LOG(LogTemp, Warning, TEXT("Character %s overlapped with Bush %s"), *GetName(), *Bush->GetName());

             // Báo cáo lên Server (Xem mục 4)
        }
    }

    void ACustomPlayerCharacter::OnCharacterEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
    {
        // Kiểm tra xem Actor va chạm có phải là ABushActor không
        ABushActor* Bush = Cast<ABushActor>(OtherActor);
        if (Bush)
        {
            // Phát hiện va chạm kết thúc với ABushActor!
            // TODO: Logic xử lý sự kiện Player đi ra khỏi bụi cỏ
            UE_LOG(LogTemp, Warning, TEXT("Character %s stopped overlapping with Bush %s"), *GetName(), *Bush->GetName());

            // Báo cáo lên Server (Xem mục 4)
        }
    }
    ```
    *   `Cast<ABushActor>(OtherActor)`: Đây là cách kiểm tra xem `OtherActor` có phải là một instance của lớp `ABushActor` hay lớp con của nó hay không. Nếu đúng, nó trả về con trỏ hợp lệ; nếu không, nó trả về `nullptr`.
    *   Quan trọng: Các sự kiện va chạm này xảy ra trên cả Server và Client. Tuy nhiên, logic báo cáo trạng thái chỉ cần thiết trên Client mà người chơi đang điều khiển Character đó. Server sẽ tự phát hiện va chạm (đáng tin cậy hơn) hoặc nhận báo cáo từ Client đáng tin cậy.

#### 4. Giao tiếp Client-to-Server (Sử dụng RPCs)

Trong kiến trúc multiplayer Server authoritative của Unreal Engine, Client không được tự ý thay đổi trạng thái game quan trọng (như "đang ở trong bụi cỏ"). Mọi thay đổi trạng thái phải được thông báo cho Server, và Server là nơi duy nhất có quyền cập nhật trạng thái authoritative và đồng bộ hóa nó với các Client khác.

*   Tại sao cần RPCs: Client cần "nói" với Server rằng "Character do tôi điều khiển vừa đi vào/ra khỏi bụi cỏ X". RPCs (Remote Procedure Calls) cung cấp cơ chế an toàn và đáng tin cậy để gọi một hàm trên Server từ Client.
*   Định nghĩa các Server RPC: Chúng ta sẽ định nghĩa các hàm `UFUNCTION` với specifier `Server` trong lớp `ACustomPlayerCharacter`.

    ```cpp
    // Trong ACustomPlayerCharacter.h:

    // RPC được gọi trên Client và thực thi trên Server
    UFUNCTION(Server, Reliable, WithValidation)
    void Server_ReportEnteredBush(ABushActor* Bush);

    UFUNCTION(Server, Reliable, WithValidation)
    void Server_ReportExitedBush(ABushActor* Bush);

    // Các hàm Validation (Tùy chọn nhưng được khuyến nghị cho Server RPC)
    // Dùng để xác minh tham số trước khi thực thi logic chính trên Server
    bool Server_ReportEnteredBush_Validate(ABushActor* Bush);
    void Server_ReportEnteredBush_Implementation(ABushActor* Bush);

    bool Server_ReportExitedBush_Validate(ABushActor* Bush);
    void Server_ReportExitedBush_Implementation(ABushActor* Bush);
    ```
    *   `Server`: Chỉ định rằng hàm này là một Server RPC. Khi được gọi trên Client, nó sẽ được gửi qua mạng để thực thi trên Server. Khi được gọi trên Server, nó sẽ thực thi trực tiếp.
    *   `Reliable`: Đảm bảo rằng RPC này sẽ được gửi đi một cách đáng tin cậy (sử dụng TCP hoặc cơ chế tương tự của UE), quan trọng cho các sự kiện thay đổi trạng thái critical như vào/ra bụi cỏ.
    *   `WithValidation`: (Tùy chọn nhưng rất tốt) Yêu cầu khai báo và triển khai thêm một hàm `_Validate` và một hàm `_Implementation`. Server sẽ gọi `_Validate` trước. Nếu `_Validate` trả về `true`, Server mới gọi `_Implementation`. Điều này giúp Server kiểm tra tính hợp lệ của dữ liệu gửi từ Client, là một lớp bảo vệ chống gian lận cơ bản (ví dụ: kiểm tra xem Character của người gửi RPC có thực sự ở gần `Bush` được báo cáo không).

*   Triển khai các RPCs:

    ```cpp
    // Trong ACustomPlayerCharacter.cpp:

    // Hàm Validation (Ví dụ đơn giản, có thể phức tạp hơn)
    bool ACustomPlayerCharacter::Server_ReportEnteredBush_Validate(ABushActor* Bush)
    {
        // TODO: Implement more robust validation.
        // Simple check: Is the Bush actor valid?
        return IsValid(Bush);
        // More advanced: Check if Character's Capsule is actually overlapping the Bush's volume on the server at this moment.
        // Requires the BushActor to be replicated and the overlap state to be checkable on the server.
    }

    void ACustomPlayerCharacter::Server_ReportEnteredBush_Implementation(ABushActor* Bush)
    {
        // Logic này CHỈ chạy trên Server
        if (HasAuthority()) // Luôn kiểm tra HasAuthority() trong các hàm quan trọng trên Server
        {
            // Nhân vật này trên Server đã đi vào Bush
            UE_LOG(LogTemp, Warning, TEXT("SERVER: Player %s entered Bush %s via RPC"), *GetName(), *Bush->GetName());

            // TODO: Thông báo cho BushVisibilityManager trên Server
            // Ví dụ:
            // if (ABushVisibilityManager* Manager = GetWorld()->GetGameState<AMyGameState>()->GetBushManager()) // Giả sử có cách lấy Manager từ GameState
            // {
            //     Manager->HandlePlayerBushEntry(this, Bush); // Truyền Character và Bush actor
            // }
            // Hoặc PlayerCharacter có thể giữ tham chiếu đến Manager nếu Manager là singleton
        }
    }

    bool ACustomPlayerCharacter::Server_ReportExitedBush_Validate(ABushActor* Bush)
    {
        // TODO: Implement validation.
        return IsValid(Bush);
    }

    void ACustomPlayerCharacter::Server_ReportExitedBush_Implementation(ABushActor* Bush)
    {
        // Logic này CHỈ chạy trên Server
         if (HasAuthority())
        {
            // Nhân vật này trên Server đã đi ra khỏi Bush
            UE_LOG(LogTemp, Warning, TEXT("SERVER: Player %s exited Bush %s via RPC"), *GetName(), *Bush->GetName());

             // TODO: Thông báo cho BushVisibilityManager trên Server
            // if (ABushVisibilityManager* Manager = GetWorld()->GetGameState<AMyGameState>()->GetBushManager())
            // {
            //     Manager->HandlePlayerBushExit(this, Bush); // Truyền Character và Bush actor
            // }
        }
    }
    ```
    *   `_Validate` và `_Implementation` là hậu tố bắt buộc khi sử dụng `WithValidation`.
    *   Luôn sử dụng `HasAuthority()` để đảm bảo code nhạy cảm chỉ chạy trên Server.
    *   `Server_ReportEnteredBush_Implementation` và `Server_ReportExitedBush_Implementation` là nơi Server xử lý sự kiện. Ở đây, chúng ta sẽ gọi các hàm tương ứng trên lớp quản lý Server (`ABushVisibilityManager`) để nó cập nhật trạng thái và tính toán lại hiển thị.

*   Gọi các Server RPC từ các hàm xử lý sự kiện va chạm:

    ```cpp
    // Trong ACustomPlayerCharacter.cpp (tiếp tục từ mục 3):

    void ACustomPlayerCharacter::OnCharacterBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
    {
        ABushActor* Bush = Cast<ABushActor>(OtherActor);
        if (Bush)
        {
             UE_LOG(LogTemp, Warning, TEXT("Character %s overlapped with Bush %s"), *GetName(), *Bush->GetName());

             // --- GỌI SERVER RPC CHỈ TỪ CLIENT SỞ HỮU ---
             // IsLocallyControlled() trả về TRUE nếu PlayerController cục bộ đang điều khiển Character này.
             // Chúng ta chỉ muốn client sở hữu Actor gửi báo cáo lên Server.
            if (IsLocallyControlled())
            {
                 UE_LOG(LogTemp, Warning, TEXT("CLIENT %s: Reporting Entry to Server"), *GetName());
                 Server_ReportEnteredBush(Bush);
            }
        }
    }

    void ACustomPlayerCharacter::OnCharacterEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
    {
        ABushActor* Bush = Cast<ABushActor>(OtherActor);
        if (Bush)
        {
            UE_LOG(LogTemp, Warning, TEXT("Character %s stopped overlapping with Bush %s"), *GetName(), *Bush->GetName());

            // --- GỌI SERVER RPC CHỈ TỪ CLIENT SỞ HỮU ---
            if (IsLocallyControlled())
            {
                 UE_LOG(LogTemp, Warning, TEXT("CLIENT %s: Reporting Exit to Server"), *GetName());
                 Server_ReportExitedBush(Bush);
            }
        }
    }
    ```
    *   `IsLocallyControlled()`: Đây là một kiểm tra cực kỳ quan trọng trong code Character/Pawn multiplayer. Nó trả về `true` trên Client nếu Character đó đang được điều khiển bởi `APlayerController` cục bộ của máy đó. Nó trả về `false` cho các Character khác (Character của Server hoặc Character của các Client khác).
    *   Chỉ Client sở hữu Character mới có thông tin đáng tin cậy về việc người chơi cục bộ của họ đang làm gì (di chuyển, va chạm cục bộ). Vì vậy, chỉ họ mới cần gửi báo cáo lên Server. Các Client khác sẽ nhận thông tin về trạng thái "trong bụi cỏ" của Character này thông qua replication từ Server.

```svg
<svg width="800" height="400" xmlns="http://www.w3.org/2000/svg">
  <style>
    .node {
      stroke: #333;
      stroke-width: 1.5;
      font-family: Arial;
      font-size: 14px;
    }
    .process { fill: #2196F3; } /* Blue */
    .decision { fill: #ff9800; } /* Orange */
    .io { fill: #FFEB3B; } /* Yellow */
    .server-label { fill: #B71C1C; font-weight: bold; } /* Dark Red */
    .client-label { fill: #1A237E; font-weight: bold; } /* Dark Blue */
    .edge { stroke: #333; stroke-width: 1.5; marker-end: url(#arrowhead); }
    .label { font-size: 12px; fill: #555; text-anchor: middle; }
     #arrowhead path { fill: #333; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" />
    </marker>
  </defs>

  <!-- Swimlanes -->
  <line x1="400" y1="0" x2="400" y2="400" stroke="#ccc" stroke-width="2"/>
  <text x="200" y="20" text-anchor="middle" class="client-label">CLIENT (Sở hữu Character)</text>
  <text x="600" y="20" text-anchor="middle" class="server-label">SERVER</text>

  <!-- Nodes -->
  <!-- Client Side -->
  <rect x="50" y="50" width="300" height="50" rx="5" ry="5" class="process"/>
  <text x="200" y="80" class="node" text-anchor="middle">Character phát hiện Overlap (OnOverlapBegin/End)</text>

  <rect x="100" y="130" width="200" height="50" rx="5" ry="5" class="decision"/>
  <text x="200" y="160" class="node" text-anchor="middle">Là Character do tôi điều khiển?</text>
  <text x="200" y="180" class="label" text-anchor="middle">(IsLocallyControlled())</text>

  <rect x="100" y="240" width="200" height="50" rx="5" ry="5" class="process"/>
  <text x="200" y="270" class="node" text-anchor="middle">Gọi Server RPC</text>
  <text x="200" y="290" class="label" text-anchor="middle">(Server_ReportEnteredBush/ExitedBush)</text>

  <!-- Server Side -->
   <rect x="450" y="300" width="300" height="50" rx="5" ry="5" class="io"/>
   <text x="600" y="330" class="node" text-anchor="middle">Server: Nhận và Thực thi Server RPC</text>

    <rect x="450" y="370" width="300" height="50" rx="5" ry="5" class="process"/>
    <text x="600" y="400" class="node" text-anchor="middle">Server: Cập nhật Trạng thái Player trong Bush Manager</text>


  <!-- Edges -->
  <path d="M200 100 V 130" class="edge"/>
  <path d="M200 180 V 240" class="edge"/>
  <path d="M300 265 H 450" class="edge"/>
  <text x="375" y="275" class="label" text-anchor="middle">Server RPC</text>

  <path d="M450 350 V 370" class="edge"/>

  <path d="M100 160 H 50" class="edge" stroke-dasharray="5,5"/>
  <text x="75" y="150" class-anchor="middle">Không -> Bỏ qua</text>


</svg>
```
*Luồng gọi Server RPC khi Character phát hiện Overlap (Client side).*

#### 5. Logic Client-side để Cập nhật Hiển thị

Sau khi Server nhận báo cáo từ Client, cập nhật trạng thái và chạy logic tính toán lại hiển thị, Server sẽ ra lệnh cho từng Client cập nhật hiển thị các Actor Player khác.

*   Cơ chế Server ra lệnh cho Client:
    *   Cách đơn giản (và khuyến nghị cho người mới): Server thay đổi biến `bHidden` của Actor Player mục tiêu (`ACustomPlayerCharacter* TargetCharacter->SetActorHiddenInGame(!bShouldBeVisible);`). Vì `bHidden` được replicate mặc định, sự thay đổi này sẽ tự động đồng bộ đến tất cả Client đã replicate `TargetCharacter`. Mỗi Client sẽ tự động ẩn/hiện Actor đó trong thế giới cục bộ của mình.
    *   Cách nâng cao hơn: Server có thể gọi một Client RPC trên `APlayerController` của người quan sát (`ObserverPlayerController->Client_UpdatePlayerVisibility(TargetCharacter, bShouldBeVisible);`). RPC này sẽ chạy trên Client của người quan sát, và Client đó sẽ tự ẩn/hiện `TargetCharacter` và có thể kích hoạt thêm hiệu ứng (như hiệu ứng biến mất/xuất hiện).

*   Logic trên Client (xảy ra tự động hoặc trong Client RPC):
    *   Khi Server thay đổi `bHidden` trên Actor Player Character, Unreal Engine tự động cập nhật giá trị `bHidden` trên bản sao của Actor đó trên mỗi Client (nếu Actor đó relevant cho Client đó). Hệ thống rendering sẽ tôn trọng cờ này.
    *   Nếu sử dụng Client RPC `Client_UpdatePlayerVisibility`, logic trong hàm này sẽ chạy trên Client của người quan sát:
        ```cpp
        // Khai báo trong ACustomPlayerCharacter.h:
        UFUNCTION(Client, Reliable) // Hoặc Unreliable nếu không cần đảm bảo 100% lệnh đến
        void Client_UpdatePlayerVisibility(ACustomPlayerCharacter* TargetPlayer, bool bShouldBeVisible);

        // Triển khai trong ACustomPlayerCharacter.cpp:
        void ACustomPlayerCharacter::Client_UpdatePlayerVisibility_Implementation(ACustomPlayerCharacter* TargetPlayer, bool bShouldBeVisible)
        {
             // Logic này chạy trên Client nhận RPC (client của Observer).
             // 'this' là Character của Observer.
             // TargetPlayer là Character cần ẩn/hiện.

            if (IsValid(TargetPlayer))
            {
                // Kiểm tra IsLocalController() nếu muốn hiệu ứng chỉ chạy trên Client sở hữu Player
                // (ví dụ: hiệu ứng biến mất của người khác chỉ thấy trên màn hình của mình)
                // if (IsLocallyControlled())
                // {
                     TargetPlayer->SetActorHiddenInGame(!bShouldBeVisible);
                    UE_LOG(LogTemp, Warning, TEXT("CLIENT %s (Observer): Setting visibility of %s to %s"),
                         *GetName(),
                         *TargetPlayer->GetName(),
                         bShouldBeVisible ? TEXT("Visible") : TEXT("Hidden"));

                    // TODO: Thêm hiệu ứng biến mất/xuất hiện nếu cần
                    // if (!bShouldBeVisible) { TriggerDisappearEffect(TargetPlayer); }
                    // else { TriggerAppearEffect(TargetPlayer); }
                // }
            }
        }
        ```
    *   Lưu ý: Hàm `Client_UpdatePlayerVisibility` cần được gọi trên `APlayerController` của Observer, không phải Character của Observer. Điều này có nghĩa là `ABushVisibilityManager` trên Server cần tìm `APlayerController` của Observer và gọi RPC này thông qua Controller. Tuy nhiên, cách đơn giản hơn là Server gọi `TargetCharacter->SetActorHiddenInGame()` trực tiếp trên Server, vì biến `bHidden` được replicate tự động. Cách này tránh việc phải gọi RPC Client phức tạp hơn. Chúng ta sẽ sử dụng cách `SetActorHiddenInGame` trên Server.

#### 6. Tệp Header (.h) và Tệp Source (.cpp) mẫu

Dưới đây là mã mẫu cho `ACustomPlayerCharacter` bao gồm các phần đã thảo luận. Giả định bạn đã tạo lớp `ACustomPlayerCharacter` kế thừa từ `ACharacter`.

ACustomPlayerCharacter.h

```cpp
// YourGame/Characters/CustomPlayerCharacter.h

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Components/CapsuleComponent.h" // Bao gồm để truy cập CapsuleComponent
#include "YourGame/Actors/BushActor.h"    // Bao gồm BushActor để sử dụng trong hàm

#include "CustomPlayerCharacter.generated.h"

UCLASS()
class YOURGAME_API ACustomPlayerCharacter : public ACharacter
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	ACustomPlayerCharacter();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	// --- Va chạm với BushActor ---

	// Hàm xử lý sự kiện khi CapsuleComponent bắt đầu overlap
	UFUNCTION()
	void OnCharacterBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

	// Hàm xử lý sự kiện khi CapsuleComponent kết thúc overlap
	UFUNCTION()
	void OnCharacterEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	// --- RPCs để báo cáo Server ---

	// Server RPC: Báo cáo Client Character đã đi vào bụi cỏ
	UFUNCTION(Server, Reliable, WithValidation)
	void Server_ReportEnteredBush(ABushActor* Bush);
	// Hàm validation và implementation được UHT yêu cầu khi dùng WithValidation
	bool Server_ReportEnteredBush_Validate(ABushActor* Bush);
	void Server_ReportEnteredBush_Implementation(ABushActor* Bush);

	// Server RPC: Báo cáo Client Character đã đi ra khỏi bụi cỏ
	UFUNCTION(Server, Reliable, WithValidation)
	void Server_ReportExitedBush(ABushActor* Bush);
	// Hàm validation và implementation
	bool Server_ReportExitedBush_Validate(ABushActor* Bush);
	void Server_ReportExitedBush_Implementation(ABushActor* Bush);

	// --- Hàm để Client cập nhật hiển thị của player khác (Được gọi từ Server) ---
	// (Xem giải thích ở Mục 5 về việc sử dụng Replication bHidden thay thế RPC Client này)
	// UFUNCTION(Client, Reliable)
	// void Client_UpdatePlayerVisibility(ACustomPlayerCharacter* TargetPlayer, bool bShouldBeVisible);
	// void Client_UpdatePlayerVisibility_Implementation(ACustomPlayerCharacter* TargetPlayer, bool bShouldBeVisible);

};
```

ACustomPlayerCharacter.cpp

```cpp
// YourGame/Characters/CustomPlayerCharacter.cpp

#include "CustomPlayerCharacter.h"
#include "Components/CapsuleComponent.h"
#include "YourGame/Actors/BushActor.h"
#include "Net/UnrealNetwork.h" // Cần cho GetLifetimeReplicatedProps nếu có biến replicate tùy chỉnh

// Optional: Bao gồm Manager Actor nếu bạn cần gọi nó trực tiếp từ Character (Không khuyến khích)
// #include "YourGame/Managers/BushVisibilityManager.h"

// Sets default values
ACustomPlayerCharacter::ACustomPlayerCharacter()
{
 	// Set this character to call Tick() every frame. You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true; // Character thường cần Tick cho di chuyển/animation...

	// --- Cấu hình Replication ---
	// Character cần được replicate
	SetReplicates(true);
	// Character sở hữu bởi PlayerController cần Owner Replication
	SetReplicateMovement(true); // Quan trọng cho di chuyển mượt trong multiplayer
	bAlwaysRelevant = true; // Character thường cần luôn relevant cho người chơi khác

	// --- Cấu hình Va chạm trên CapsuleComponent mặc định ---
	// Đảm bảo va chạm được bật
	GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	// Đảm bảo Object Type là Pawn (thường là mặc định)
	GetCapsuleComponent()->SetCollisionObjectType(ECollisionChannel::ECC_Pawn);
	// Đặt phản ứng Overlap với kênh của ABushActor (ECC_WorldDynamic như trong ABushActor)
	GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldDynamic, ECR_Overlap);
	// Đảm bảo tạo sự kiện va chạm (overlap events) được bật
	GetCapsuleComponent()->SetGenerateOverlapEvents(true);


	// --- Bind các hàm xử lý sự kiện va chạm trên CapsuleComponent ---
	GetCapsuleComponent()->OnComponentBeginOverlap.AddDynamic(this, &ACustomPlayerCharacter::OnCharacterBeginOverlap);
	GetCapsuleComponent()->OnComponentEndOverlap.AddDynamic(this, &ACustomPlayerCharacter::OnCharacterEndOverlap);

}

// Called when the game starts or when spawned
void ACustomPlayerCharacter::BeginPlay()
{
	Super::BeginPlay();

	// Logic khởi tạo
	// HasAuthority() kiểm tra xem code đang chạy trên Server hay Client (Host cũng là Server)
	if (HasAuthority())
	{
		UE_LOG(LogTemp, Warning, TEXT("Player Character spawned on Server: %s"), *GetName());
	}
	else
	{
		// IsLocallyControlled() kiểm tra xem đây có phải Character của client cục bộ không
		if (IsLocallyControlled())
		{
			UE_LOG(LogTemp, Warning, TEXT("Local Player Character spawned on Client: %s"), *GetName());
		}
		else
		{
			UE_LOG(LogTemp, Warning, TEXT("Remote Player Character spawned on Client: %s"), *GetName());
		}
	}
}

// Called every frame
void ACustomPlayerCharacter::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}

// Called to bind functionality to input
void ACustomPlayerCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	// Bind input actions here (e.g., Movement)
	// Input processing chỉ nên chạy trên Client sở hữu IsLocallyControlled()
	// Logic di chuyển Character đã có sẵn trong ACharacter và được replicate bởi SetReplicateMovement(true)
}

// --- Triển khai hàm xử lý va chạm ---

void ACustomPlayerCharacter::OnCharacterBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	// Kiểm tra xem Actor va chạm có phải là ABushActor không
	ABushActor* Bush = Cast<ABushActor>(OtherActor);
	if (Bush)
	{
		UE_LOG(LogTemp, Warning, TEXT("Character %s overlapped with Bush %s"), *GetName(), *Bush->GetName());

		// GỌI SERVER RPC CHỈ TỪ CLIENT SỞ HỮU ACTOR NÀY
		if (IsLocallyControlled())
		{
			UE_LOG(LogTemp, Warning, TEXT("CLIENT %s: Reporting Entry to Server for Bush %s"), *GetName(), *Bush->GetName());
			Server_ReportEnteredBush(Bush);
		}
	}
}

void ACustomPlayerCharacter::OnCharacterEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	// Kiểm tra xem Actor va chạm có phải là ABushActor không
	ABushActor* Bush = Cast<ABushActor>(OtherActor);
	if (Bush)
	{
		UE_LOG(LogTemp, Warning, TEXT("Character %s stopped overlapping with Bush %s"), *GetName(), *Bush->GetName());

		// GỌI SERVER RPC CHỈ TỪ CLIENT SỞ HỮU ACTOR NÀY
		if (IsLocallyControlled())
		{
			UE_LOG(LogTemp, Warning, TEXT("CLIENT %s: Reporting Exit to Server for Bush %s"), *GetName(), *Bush->GetName());
			Server_ReportExitedBush(Bush);
		}
	}
}

// --- Triển khai RPCs để báo cáo Server ---

bool ACustomPlayerCharacter::Server_ReportEnteredBush_Validate(ABushActor* Bush)
{
    // Validation đơn giản: Đảm bảo tham chiếu Bush là hợp lệ
    if (!IsValid(Bush))
    {
        UE_LOG(LogTemp, Warning, TEXT("SERVER: RPC Server_ReportEnteredBush_Validate failed for Player %s - Invalid Bush reference"), *GetName());
        return false;
    }
    // TODO: Có thể thêm validation phức tạp hơn, ví dụ: kiểm tra khoảng cách giữa Player và Bush
    // hoặc kiểm tra xem Capsule Component của Player có thực sự overlap với Bush trên Server không.
    // Việc kiểm tra overlap trên server yêu cầu CapsuleComponent của Character cũng phải
    // được cấu hình va chạm trên server và Bush Actor phải replicated.
    // Với kiến trúc hiện tại, Server cũng phát hiện va chạm, nên RPC này chủ yếu là
    // để báo cáo nhanh từ client. Validation có thể đơn giản chỉ kiểm tra tham chiếu.
    return true;
}

void ACustomPlayerCharacter::Server_ReportEnteredBush_Implementation(ABushActor* Bush)
{
    // Logic này CHỈ chạy trên Server authoritative
    if (HasAuthority())
    {
        UE_LOG(LogTemp, Warning, TEXT("SERVER: Player %s officially ENTERED Bush %s"), *GetName(), *Bush->GetName());

        // TODO: Gọi hàm xử lý trên Server BushVisibilityManager
        // Ví dụ:
        // if (ABushVisibilityManager* Manager = GetWorld()->GetGameState<AMyGameState>()->GetBushManager())
        // {
        //     Manager->HandlePlayerBushEntry(this, Bush);
        // }
        // Character này trên Server có thể lưu lại Bush đang ở (dữ liệu Server Only)
        // CurrentBushActor = Bush; // Cần khai báo TWeakObjectPtr<ABushActor> CurrentBushActor; (Server Only)
    }
}

bool ACustomPlayerCharacter::Server_ReportExitedBush_Validate(ABushActor* Bush)
{
    // Validation đơn giản: Đảm bảo tham chiếu Bush là hợp lệ
    if (!IsValid(Bush))
    {
         UE_LOG(LogTemp, Warning, TEXT("SERVER: RPC Server_ReportExitedBush_Validate failed for Player %s - Invalid Bush reference"), *GetName());
        return false;
    }
     // TODO: Có thể thêm validation phức tạp hơn.
    return true;
}

void ACustomPlayerCharacter::Server_ReportExitedBush_Implementation(ABushActor* Bush)
{
    // Logic này CHỈ chạy trên Server authoritative
    if (HasAuthority())
    {
        UE_LOG(LogTemp, Warning, TEXT("SERVER: Player %s officially EXITED Bush %s"), *GetName(), *Bush->GetName());

        // TODO: Gọi hàm xử lý trên Server BushVisibilityManager
        // Ví dụ:
        // if (ABushVisibilityManager* Manager = GetWorld()->GetGameState<AMyGameState>()->GetBushManager())
        // {
        //     Manager->HandlePlayerBushExit(this, Bush);
        // }
        // Đặt lại Bush đang ở (dữ liệu Server Only)
        // CurrentBushActor = nullptr; // Cần khai báo TWeakObjectPtr<ABushActor> CurrentBushActor; (Server Only)
    }
}

// --- Triển khai hàm để Client cập nhật hiển thị của player khác (Được gọi từ Server) ---
// (Nếu bạn chọn dùng RPC Client thay vì chỉ dựa vào replication bHidden)
// void ACustomPlayerCharacter::Client_UpdatePlayerVisibility_Implementation(ACustomPlayerCharacter* TargetPlayer, bool bShouldBeVisible)
// {
//     if (IsValid(TargetPlayer))
//     {
//         TargetPlayer->SetActorHiddenInGame(!bShouldBeVisible);
//         UE_LOG(LogTemp, Warning, TEXT("CLIENT %s: Setting visibility of %s to %s"),
//              *GetName(),
//              *TargetPlayer->GetName(),
//              bShouldBeVisible ? TEXT("Visible") : TEXT("Hidden"));

//         // TODO: Thêm hiệu ứng biến mất/xuất hiện nếu cần
//     }
// }
```

#### 7. Giải thích Chi tiết Mã Nguồn

*   Constructor (`ACustomPlayerCharacter::ACustomPlayerCharacter()`):
    *   `SetReplicates(true);`, `SetReplicateMovement(true);`, `bAlwaysRelevant = true;`: Các thiết lập cơ bản để Character hoạt động trong multiplayer, đảm bảo nó và chuyển động của nó được đồng bộ giữa Server và Client.
    *   Cấu hình CapsuleComponent: Đảm bảo CapsuleComponent có thể phát hiện overlap với `ABushActor` bằng cách đặt `ResponseToChannel` của kênh `ECC_WorldDynamic` thành `ECR_Overlap`.
    *   Bind Overlap Events: Gắn hàm `OnCharacterBeginOverlap` và `OnCharacterEndOverlap` vào delegate tương ứng của CapsuleComponent. `AddDynamic` là cần thiết cho các hàm `UFUNCTION()`.
*   `BeginPlay()`: Kiểm tra `HasAuthority()` và `IsLocallyControlled()` là một pattern tốt để hiểu môi trường thực thi code (Server, Client sở hữu, Client không sở hữu).
*   `OnCharacterBeginOverlap`, `OnCharacterEndOverlap`:
    *   Các hàm này được gọi khi Character bắt đầu/kết thúc overlap với bất kỳ Actor nào có component tạo overlap events mà phản ứng với CapsuleComponent của Character.
    *   `Cast<ABushActor>(OtherActor)`: Dùng để lọc chỉ xử lý khi Actor va chạm là `ABushActor`. `Cast` là hàm của Unreal Engine để thử ép kiểu con trỏ Actor/Object; nó trả về `nullptr` nếu ép kiểu thất bại.
    *   `if (IsLocallyControlled())`: Đây là kiểm tra cực kỳ quan trọng. Logic gọi Server RPC chỉ được thực hiện trên Client mà người chơi cục bộ đang điều khiển Character này. Các Client khác và Server không gọi RPC này từ hàm overlap cục bộ của họ.
    *   `Server_ReportEnteredBush(Bush);`, `Server_ReportExitedBush(Bush);`: Gọi Server RPC để báo cáo sự kiện cho Server. Server sẽ nhận Bush actor làm tham số.
*   `UFUNCTION(Server, Reliable, WithValidation)`: Macro khai báo Server RPC với các đặc tính: chạy trên Server, đáng tin cậy, và có validation.
*   `_Validate` hàm:
    *   Chạy trên Server trước `_Implementation`.
    *   Cung cấp cơ hội để xác minh dữ liệu gửi từ Client. Trả về `false` sẽ hủy thực thi `_Implementation` và có thể coi là dấu hiệu gian lận.
    *   Ví dụ đơn giản chỉ kiểm tra tính hợp lệ của con trỏ `Bush`. Xác minh đầy đủ hơn sẽ phức tạp hơn.
*   `_Implementation` hàm:
    *   Chạy trên Server chỉ khi `_Validate` trả về `true`.
    *   Chứa logic xử lý sự kiện trên Server authoritative.
    *   `if (HasAuthority())`: Mặc dù hàm này chỉ nên được gọi trên Server do macro `Server`, kiểm tra `HasAuthority()` bên trong là một lớp phòng vệ tốt và giúp code dễ hiểu hơn về nơi nó *nên* chạy.
    *   `// TODO: Gọi hàm xử lý trên Server BushVisibilityManager`: Đây là nơi tích hợp với bước tiếp theo. Thay vì Character tự xử lý logic hiển thị, nó ủy thác cho một lớp quản lý tập trung trên Server.
*   `UFUNCTION(Client, Reliable) Client_UpdatePlayerVisibility` (Đã comment out): Macro khai báo Client RPC. Nếu được sử dụng, Server sẽ gọi hàm này trên `APlayerController` của một Client cụ thể, và logic bên trong `_Implementation` sẽ chạy trên Client đó. Như đã giải thích, dựa vào replication `bHidden` của Actor là cách đơn giản hơn.
*   `GetCapsuleComponent()`: Hàm trong lớp `ACharacter` để lấy con trỏ tới `UCapsuleComponent` mặc định.
*   `HasAuthority()`: Hàm trong `AActor` trả về `true` nếu Actor đang chạy trên Server (bao gồm Listen Server Host). Trả về `false` trên các Client kết nối.
*   `IsLocallyControlled()`: Hàm trong `APawn` trả về `true` nếu Pawn (hoặc Character) đang được điều khiển bởi `APlayerController` cục bộ. Trả về `false` nếu bị điều khiển bởi AI Controller hoặc Remote PlayerController.

#### 8. Kết nối với ABushVisibilityManager (Bước tiếp theo)

Với code `ACustomPlayerCharacter` này, Character của bạn đã có khả năng:
1.  Phát hiện va chạm với `ABushActor`.
2.  Trên Client sở hữu, báo cáo sự kiện va chạm này cho Server thông qua Server RPCs.

Các RPC `Server_ReportEnteredBush` và `Server_ReportExitedBush` hiện tại chỉ log thông báo. Bước tiếp theo là tích hợp chúng với logic quản lý trạng thái hiển thị.

*   Lớp `ABushVisibilityManager` (hoặc logic tương ứng trong GameMode) trên Server sẽ cần:
    *   Có các hàm `HandlePlayerBushEntry(ACustomPlayerCharacter* Player, ABushActor* Bush)` và `HandlePlayerBushExit(ACustomPlayerCharacter* Player, ABushActor* Bush)`.
    *   Được gọi từ `Server_ReportEnteredBush_Implementation` và `Server_ReportExitedBush_Implementation` của Character.
    *   Lưu trữ trạng thái người chơi nào đang ở trong BushActor nào.
    *   Chứa logic `RecomputeVisibilityForAll` để tính toán ai thấy ai dựa trên quy tắc hiển thị.
    *   Ra lệnh ẩn/hiện các Player Character bằng cách gọi `TargetCharacter->SetActorHiddenInGame(!bShouldBeVisible);` trên Server, dựa vào kết quả tính toán.

Character chỉ đóng vai trò báo cáo sự kiện và là đối tượng bị/được Server ra lệnh ẩn/hiện. Nó không chứa logic tính toán hiển thị phức tạp hoặc trạng thái toàn cục của hệ thống bụi cỏ. Việc này đảm bảo tách biệt trách nhiệm và giữ cho code của Character gọn gàng.

```svg
<svg width="800" height="300" xmlns="http://www.w3.org/2000/svg">
  <style>
    .node {
      stroke: #333;
      stroke-width: 1.5;
      font-family: Arial;
      font-size: 14px;
    }
    .actor { fill: #f9f9f9; }
    .manager { fill: #FFCDD2; } /* Light Red */
    .edge { stroke: #333; stroke-width="1.5"; marker-end="url(#arrowhead)"; }
    .label { font-size: 12px; fill: #555; text-anchor: middle; }
     #arrowhead path { fill: #333; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" />
    </marker>
  </defs>

  <!-- Nodes -->
  <rect x="50" y="100" width="200" height="50" rx="5" ry="5" class="actor"/>
  <text x="150" y="130" class="node" text-anchor="middle">ACustomPlayerCharacter</text>
  <text x="150" y="150" class="label" text-anchor="middle">(Client báo cáo RPC)</text>

  <rect x="300" y="100" width="200" height="50" rx="5" ry="5" class="actor"/>
  <text x="400" y="130" class="node" text-anchor="middle">ABushActor</text>
  <text x="400" y="150" class="label" text-anchor="middle">(Vùng Va chạm)</text>

  <rect x="550" y="100" width="200" height="50" rx="5" ry="5" class="manager"/>
  <text x="650" y="130" class="node" text-anchor="middle">ABushVisibilityManager</text>
   <text x="650" y="150" class="label" text-anchor="middle">(Server Logic)</text>


  <!-- Edges -->
  <path d="M250 125 H 300" class="edge"/>
  <text x="275" y="115" class="label" text-anchor="middle">Overlap Detected</text>

  <path d="M250 170 C 250 200, 650 200, 650 150" class="edge"/>
  <text x="450" y="180" class="label" text-anchor="middle">Server RPC báo cáo</text>
  <text x="450" y="195" class="label" text-anchor="middle">(HandlePlayerBushEntry/Exit)</text>

  <path d="M650 150 V 220" class="edge"/>
  <text x="660" y="185" class="label" text-anchor="start">Tính toán lại hiển thị</text>

  <path d="M650 220 C 650 250, 150 250, 150 150" class="edge"/>
  <text x="400" y="260" class="label" text-anchor="middle">Server ra lệnh ẩn/hiện</text>
  <text x="400" y="275" class="label" text-anchor="middle">(SetActorHiddenInGame replicate)</text>

</svg>
```
*Sơ đồ luồng tương tác giữa Character, BushActor và Visibility Manager.*