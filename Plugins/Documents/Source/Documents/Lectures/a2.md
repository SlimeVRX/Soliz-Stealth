# Tài liệu Thiết kế Cấp cao: Triển Khai Tính Năng Multiplayer "Bụi Cỏ" Trong Unreal Engine (C++)

Tài liệu này cung cấp thiết kế chi tiết ở cấp cao cho tính năng "bụi cỏ" trong game multiplayer, dựa trên các khái niệm cốt lõi về kiến trúc client-server, replication, RPCs, và va chạm đã trình bày trong tài liệu tham khảo "Khái Niệm Cốt Lõi Để Xây Dựng Tính Năng Multiplayer 'Bụi Cỏ' Trong Unreal Engine (C++)". Mục tiêu là trình bày rõ ràng cấu trúc hệ thống, các lớp C++ đề xuất, luồng logic, và giải thích lý do đằng sau các quyết định thiết kế, giúp người mới bắt đầu dễ dàng nắm bắt.

## 1. Tổng quan và Diễn giải Quy tắc

Yêu cầu Chức năng:
Tính năng "bụi cỏ" cho phép người chơi ẩn mình khỏi tầm nhìn của người chơi khác khi họ ở bên trong một khu vực được định nghĩa là bụi cỏ. Đây là một tính năng chiến thuật quan trọng trong nhiều loại game.

Diễn giải Quy tắc Hiển thị:
Dựa trên yêu cầu ban đầu và để đảm bảo tính nhất quán trong môi trường multiplayer, chúng ta diễn giải các quy tắc hiển thị như sau:

*   Quy tắc 1 (Ẩn): Nếu PlayerCharacter (Mục tiêu) đang ở trong bất kỳ bụi cỏ nào, thì bất kỳ PlayerController nào (Người quan sát) ở *bên ngoài* bụi cỏ đó sẽ *không* thấy PlayerCharacter Mục tiêu.
*   Quy tắc 2 (Hiện trong cùng bụi cỏ): Nếu PlayerCharacter (Mục tiêu) đang ở trong một bụi cỏ, và PlayerController (Người quan sát) cũng đang ở trong *cùng* bụi cỏ đó, thì PlayerController Người quan sát sẽ *thấy* PlayerCharacter Mục tiêu.
*   Quy tắc 3 (Hiện khi cả hai đều ngoài): Nếu PlayerCharacter (Mục tiêu) đang ở *ngoài* bụi cỏ, và PlayerController (Người quan sát) cũng đang ở *ngoài* bụi cỏ, thì PlayerController Người quan sát sẽ *thấy* PlayerCharacter Mục tiêu.
*   Quy tắc 4 (Người chơi thấy chính mình): Mỗi người chơi luôn thấy PlayerCharacter mà họ điều khiển, bất kể vị trí của họ hay các bụi cỏ.

Áp dụng cho các trường hợp Player 1, 2, 3:
*   Tình huống P1 vào bụi cỏ, P2, P3 ngoài:
    *   P1 ở trong bụi cỏ A. P2, P3 ở ngoài.
    *   Server áp dụng:
        *   Đối với Client P1: P1 thấy chính mình (Quy tắc 4).
        *   Đối với Client P2: P2 ngoài bụi cỏ. P1 trong bụi cỏ A. P2 không thấy P1 (Quy tắc 1). P2 thấy P3 (cả hai ngoài - Quy tắc 3).
        *   Đối với Client P3: Tương tự Client P2. P3 ngoài bụi cỏ. P1 trong bụi cỏ A. P3 không thấy P1 (Quy tắc 1). P3 thấy P2 (cả hai ngoài - Quy tắc 3).
*   Tình huống P1, P2 trong bụi cỏ A, P3 ngoài:
    *   P1, P2 ở trong bụi cỏ A. P3 ở ngoài.
    *   Server áp dụng:
        *   Đối với Client P1: P1 thấy chính mình (Quy tắc 4). P2 trong cùng bụi cỏ A. P1 thấy P2 (Quy tắc 2). P3 ngoài bụi cỏ. P1 thấy P3 (P1 trong bụi cỏ A, P3 ngoài -> Quy tắc 1 áp dụng theo chiều ngược lại? Không, logic quyết định người quan sát thấy mục tiêu. P1 thấy P3 vì P3 ngoài, P1 không bị ẩn khỏi người ngoài. Quy tắc 3 áp dụng).
        *   Đối với Client P2: Tương tự Client P1. P2 thấy chính mình (Quy tắc 4). P1 trong cùng bụi cỏ A. P2 thấy P1 (Quy tắc 2). P3 ngoài bụi cỏ. P2 thấy P3 (cả hai ngoài -> Quy tắc 3).
        *   Đối với Client P3: P3 thấy chính mình (Quy tắc 4). P1, P2 trong bụi cỏ A. P3 ngoài bụi cỏ. P3 không thấy P1 (Quy tắc 1). P3 không thấy P2 (Quy tắc 1).
*   Tình huống P1, P2, P3 trong bụi cỏ A:
    *   P1, P2, P3 ở trong bụi cỏ A.
    *   Server áp dụng:
        *   Đối với Client P1: P1 thấy chính mình (Quy tắc 4). P2, P3 trong cùng bụi cỏ A. P1 thấy P2 và P3 (Quy tắc 2).
        *   Đối với Client P2: Tương tự Client P1. P2 thấy chính mình (Quy tắc 4). P1, P3 trong cùng bụi cỏ A. P2 thấy P1 và P3 (Quy tắc 2).
        *   Đối với Client P3: Tương tự Client P1. P3 thấy chính mình (Quy tắc 4). P1, P2 trong cùng bụi cỏ A. P3 thấy P1 và P2 (Quy tắc 2).

Giả định:
*   Mỗi thể tích bụi cỏ là một thực thể riêng biệt (`ABushActor`). Người chơi chỉ "trong bụi cỏ" nếu họ overlap với thể tích của một `ABushActor` cụ thể.
*   Không xét đến trường hợp người chơi ở trong các bụi cỏ khác nhau (ví dụ: P1 trong bụi A, P2 trong bụi B, P3 ngoài). Quy tắc hiện tại đơn giản chỉ xét cùng một bụi cỏ. Nếu cần phức tạp hơn, logic trên server sẽ cần mở rộng để theo dõi người chơi trong từng bụi cỏ riêng biệt và áp dụng quy tắc cho từng cặp người chơi dựa trên việc họ có ở *cùng một bụi cỏ* hay không. Thiết kế hiện tại tập trung vào trường hợp "cùng một bụi cỏ" hoặc "một người trong, một người ngoài".

## 2. Kiến trúc Hệ thống

Hệ thống bụi cỏ bao gồm các thành phần chính tương tác trong kiến trúc Client-Server của Unreal Engine:

*   `ACustomPlayerCharacter`: Đại diện cho nhân vật của người chơi trong thế giới game. Tồn tại và được replicate trên cả Server và Client. Trên Server, nó phát hiện va chạm với `ABushActor`. Trên Client, nó hiển thị hoặc ẩn dựa trên lệnh từ Server.
*   `ABushActor`: Đại diện cho khu vực bụi cỏ. Là một `AActor` với một thể tích va chạm. Tồn tại và được replicate trên cả Server và Client.
*   Logic Phía Server (trong `AGameModeBase` hoặc `ABushVisibilityManager`): Thành phần *chỉ chạy trên Server*. Đây là nơi trung tâm quản lý trạng thái người chơi nào đang ở trong bụi cỏ nào và áp dụng các quy tắc hiển thị để ra lệnh cho các client cập nhật.

```svg
<svg width="800" height="400" xmlns="http://www.w3.org/2000/svg">
  <style>
    .node {
      stroke: #333;
      stroke-width: 1.5;
      font-family: Arial;
      font-size: 14px;
    }
    .rect-server-only { fill: #FFCDD2; } /* Light Red */
    .rect-replicated { fill: #C8E6C9; }  /* Light Green */
    .text-server-only { fill: #B71C1C; } /* Dark Red */
    .text-replicated { fill: #2E7D32; } /* Dark Green */
    .edge { stroke: #333; stroke-width: 1.5; marker-end: url(#arrowhead); }
    .label { font-size: 12px; fill: #555; text-anchor: middle; }
     #arrowhead path { fill: #333; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" />
    </marker>
  </defs>

  <!-- Nodes -->
  <rect x="300" y="50" width="200" height="50" rx="5" ry="5" class="rect-server-only"/>
  <text x="400" y="80" class="node text-server-only" text-anchor="middle">Server Logic</text>
  <text x="400" y="100" class="label" text-anchor="middle">(AGameModeBase / ABushVisibilityManager)</text>

  <rect x="50" y="200" width="200" height="50" rx="5" ry="5" class="rect-replicated"/>
  <text x="150" y="230" class="node text-replicated" text-anchor="middle">Client A</text>

   <rect x="300" y="200" width="200" height="50" rx="5" ry="5" class="rect-replicated"/>
  <text x="400" y="230" class="node text-replicated" text-anchor="middle">ABushActor (Replicated)</text>

  <rect x="550" y="200" width="200" height="50" rx="5" ry="5" class="rect-replicated"/>
  <text x="650" y="230" class="node text-replicated" text-anchor="middle">Client B</text>
  
   <rect x="50" y="300" width="200" height="50" rx="5" ry="5" class="rect-replicated"/>
  <text x="150" y="330" class="node text-replicated" text-anchor="middle">ACustomPlayerCharacter (Replicated)</text>
  <text x="150" y="350" class="label" text-anchor="middle">Client A's View</text>

  <rect x="550" y="300" width="200" height="50" rx="5" ry="5" class="rect-replicated"/>
  <text x="650" y="330" class="node text-replicated" text-anchor="middle">ACustomPlayerCharacter (Replicated)</text>
   <text x="650" y="350" class="label" text-anchor="middle">Client B's View</text>


  <!-- Edges -->
  <path d="M400 100 V 200" class="edge"/>
    <text x="410" y="150" class="label" text-anchor="start">Quản lý trạng thái</text>

  <path d="M250 225 H 300" class="edge"/>
     <text x="275" y="215" class="label" text-anchor="middle">Hiển thị Actor / Xử lý lệnh từ Server</text>
  <path d="M500 225 H 550" class="edge"/>
     <text x="525" y="215" class="label" text-anchor="middle">Hiển thị Actor / Xử lý lệnh từ Server</text>

  <path d="M150 250 V 300" class="edge"/>
     <text x="160" y="275" class="label" text-anchor="start">Điều khiển Character</text>

  <path d="M650 250 V 300" class="edge"/>
     <text x="640" y="275" class="label" text-anchor="end">Điều khiển Character</text>

  <path d="M150 300 C 150 270, 400 270, 400 200" class="edge"/>
    <text x="275" y="280" class="label" text-anchor="middle">Va chạm (Client side preview) -> RPC báo Server</text>

  <path d="M650 300 C 650 270, 400 270, 400 200" class="edge"/>
     <text x="525" y="280" class="label" text-anchor="middle">Va chạm (Client side preview) -> RPC báo Server</text>

   <path d="M400 100 C 400 130, 150 130, 150 200" class="edge"/>
    <text x="275" y="140" class="label" text-anchor="middle">Server ra lệnh hiển thị (qua Replication)</text>

   <path d="M400 100 C 400 130, 650 130, 650 200" class="edge"/>
    <text x="525" y="140" class="label" text-anchor="middle">Server ra lệnh hiển thị (qua Replication)</text>


</svg>
```

Vai trò của Server (Authoritative) và Client:

*   Server: Là trung tâm quyết định đáng tin cậy.
    *   Server là nơi duy nhất lưu giữ trạng thái chính xác về việc người chơi nào đang ở trong bụi cỏ nào.
    *   Server nhận thông báo về va chạm vào/ra bụi cỏ từ các client (qua RPC).
    *   Server áp dụng *tất cả* các quy tắc hiển thị đã diễn giải ở mục 1. Logic này chạy hoàn toàn trên Server.
    *   Server ra lệnh cho các Client cụ thể ẩn hoặc hiện các Actor Player khác. Việc này có thể thực hiện thông qua cơ chế Replication biến `bHidden` của Actor hoặc thông qua Client RPCs (chi tiết ở mục 5).
    > Tại sao Server phải là nơi quyết định cuối cùng? Để ngăn chặn gian lận. Nếu client tự quyết định xem họ có thấy người chơi khác hay không dựa trên vị trí cục bộ của họ, một client gian lận có thể sửa đổi game của họ để luôn thấy tất cả mọi người, bỏ qua quy tắc bụi cỏ. Server là "trọng tài" công bằng, đảm bảo mọi người đều tuân thủ cùng một luật chơi và trạng thái hiển thị là như nhau (trong giới hạn của độ trễ mạng) đối với tất cả các Client.
*   Client:
    *   Client chạy mô phỏng thế giới game cục bộ và phát hiện các sự kiện va chạm ban đầu (Client-side overlap detection).
    *   Client báo cáo các sự kiện va chạm này cho Server thông qua Server RPCs. Client không tự ý thay đổi trạng thái "trong bụi cỏ" của mình hoặc trạng thái hiển thị của người chơi khác dựa trên va chạm cục bộ.
    *   Client nhận lệnh từ Server (qua replication hoặc Client RPCs) và cập nhật hiển thị các Actor Player trong thế giới game của mình.

## 3. Các Lớp C++ Chính (Đề xuất)

Đây là các lớp C++ quan trọng cần thiết để triển khai tính năng:

### `ABushActor` (Đại diện cho bụi cỏ)

*   Kế thừa từ: `AActor`
*   Cấu hình Replication: `SetReplicates(true);` trong constructor hoặc `bReplicates = true;` trong Blueprint Default. Actor này cần được replicate để tồn tại và có thể được tham chiếu trên cả Server và Client.
*   Thành phần chính:
    *   `UPROPERTY(VisibleAnywhere, BlueprintReadOnly)`
        `UBoxComponent* BushOverlapVolume;`
        *   Một component thể tích (Box hoặc Sphere/Capsule).
        *   Cấu hình Collision: Cấu hình `Object Type` của component này thành một loại phù hợp (ví dụ: `WorldDynamic` hoặc một Custom Channel `BushVolume`). Cấu hình `Response` của kênh `Pawn` hoặc `Character` (tùy thuộc vào Character của bạn thuộc loại nào) thành `Overlap`. Cấu hình Response của các kênh khác thành `Ignore` hoặc `Block` tùy thuộc vào tương tác mong muốn của bụi cỏ với các vật thể khác.
        *   Mục đích: Phát hiện khi các Actor (đặc biệt là Player Character) đi vào hoặc đi ra khỏi thể tích bụi cỏ.
*   Các thuộc tính có thể có:
    *   `UPROPERTY(EditAnywhere, BlueprintReadOnly)`
        `int32 BushID;`
        *   Nếu cần phân biệt các bụi cỏ khác nhau hoặc nhóm chúng lại.
*   Các hàm xử lý sự kiện va chạm:
    Các sự kiện va chạm (`OnComponentBeginOverlap`, `OnComponentEndOverlap`) của `BushOverlapVolume` sẽ được kích hoạt trên cả Server và Client. Tuy nhiên, logic xử lý chính chỉ nên chạy trên Server.
    *   Bind các hàm xử lý sự kiện trong C++:
        ```cpp
        // Trong constructor của ABushActor:
        BushOverlapVolume->OnComponentBeginOverlap.AddDynamic(this, &ABushActor::OnOverlapBegin);
        BushOverlapVolume->OnComponentEndOverlap.AddDynamic(this, &ABushActor::OnOverlapEnd);

        // Khai báo hàm:
        UFUNCTION()
        void OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

        UFUNCTION()
        void OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
        ```
    *   Mục đích của hàm xử lý trên Server: Khi Server nhận sự kiện `OnOverlapBegin` từ một Player Character, nó sẽ coi player đó đã vào bụi cỏ này và cập nhật trạng thái nội bộ. Khi nhận `OnOverlapEnd`, nó coi player đó đã ra khỏi bụi cỏ. Các hàm này CHỈ NÊN chứa logic gọi đến Server Logic Manager để báo cáo sự kiện, hoặc Server Logic Manager sẽ trực tiếp xử lý trong các hàm này.

### `ACustomPlayerCharacter` (Hoặc lớp kế thừa từ `ACharacter`)

*   Kế thừa từ: `ACharacter` (hoặc `APawn`). Cấu hình `SetReplicates(true);` trong constructor.
*   Thành phần chính: Các component mặc định của Character (Mesh, Movement Component, Capsule Component cho va chạm). Capsule Component thường là nơi phát hiện va chạm với BushActor.
*   Cấu hình Collision: Capsule Component của Character cần được cấu hình `Object Type` là `Pawn` hoặc `Character` và `Response` là `Overlap` với kênh va chạm của BushActor (`BushVolume` hoặc `WorldDynamic` của BushActor).
*   Thuộc tính để theo dõi trạng thái (Server side):
    *   `// Server Only state tracking`
    *   `TWeakObjectPtr<ABushActor> CurrentBushActor;`
        *   Lưu giữ tham chiếu yếu (weak reference) đến bụi cỏ mà người chơi đang ở trong. Chỉ cần trên Server. Server sẽ cập nhật khi nhận thông báo từ Client hoặc tự phát hiện va chạm (xem thảo luận ở mục 6).
    *   `// Optional Client side prediction/visuals (non-authoritative)`
    *   `UPROPERTY(Transient)` // Không cần lưu/tải
    *   `bool bIsLocallyConcealed;` // Trạng thái ẩn cục bộ trên client để điều khiển hiển thị. Server sẽ ra lệnh cập nhật biến này (xem bên dưới) hoặc client tự suy đoán (phức tạp hơn, không khuyến khích cho người mới).
*   Các hàm RPC (Remote Procedure Call): Được gọi trên Client để báo cáo sự kiện lên Server. Phải được gọi bởi Actor mà Client sở hữu (`IsLocallyControlled()`). Character thường là Actor được PlayerController sở hữu.
    ```cpp
    // Khai báo trong header (.h):
    UFUNCTION(Server, Reliable)
    void Server_ReportBushEntry(ABushActor* Bush);

    UFUNCTION(Server, Reliable)
    void Server_ReportBushExit(ABushActor* Bush);
    ```
    *   `Server_ReportBushEntry(ABushActor* Bush)`: Được gọi trên Client khi Character của client đó phát hiện va chạm bắt đầu với một `ABushActor`. Hàm này sẽ chạy trên Server. Server nhận `Bush` actor được tham chiếu, xác minh (tùy chọn) và cập nhật trạng thái `CurrentBushActor` của Character này trên Server. Sau đó, Server logic sẽ được kích hoạt để tính toán lại hiển thị cho tất cả mọi người.
    *   `Server_ReportBushExit(ABushActor* Bush)`: Được gọi trên Client khi Character của client đó phát hiện va chạm kết thúc với một `ABushActor`. Hàm này sẽ chạy trên Server. Server nhận `Bush` actor, xác minh và đặt `CurrentBushActor` về `nullptr` trên Server. Server logic lại được kích hoạt.
    *   Reliable: Đảm bảo RPC này sẽ đến được Server (quan trọng vì trạng thái vào/ra bụi cỏ là critical).
*   Hàm để client cập nhật hiển thị của *các player khác*: Hàm này được Server gọi trên Client cụ thể để ra lệnh cập nhật hiển thị.
    ```cpp
    // Khai báo trong header (.h):
    UFUNCTION(Client, Reliable)
    void Client_UpdatePlayerVisibility(ACustomPlayerCharacter* TargetPlayer, bool bShouldBeVisible);
    ```
    *   `Client_UpdatePlayerVisibility(ACustomPlayerCharacter* TargetPlayer, bool bShouldBeVisible)`: Được Server gọi trên một Client `ObserverPlayerController` cụ thể. Hàm này chạy trên Client đó. `TargetPlayer` là Actor PlayerCharacter mà Client Observer cần ẩn/hiện. `bShouldBeVisible` là cờ hiển thị.
    *   Logic trong hàm `Client_UpdatePlayerVisibility` (trên Client):
        ```cpp
        if (TargetPlayer)
        {
            // Ẩn hoặc hiện Actor.
            // Cách 1: Dựa vào replication biến bHidden (được Server thay đổi)
            // Server sẽ gọi TargetPlayer->SetActorHiddenInGame(!bShouldBeVisible); trên Server.
            // Client sẽ nhận bản replicate của bHidden và tự cập nhật hiển thị.
            // Trong trường hợp này, hàm Client_UpdatePlayerVisibility không cần thiết cho việc ẩn/hiện bHidden
            // nhưng có thể dùng để kích hoạt hiệu ứng khác trên client.

            // Cách 2 (Nếu không dùng replication bHidden hoặc cần hiệu ứng): Dùng RPC Client
            TargetPlayer->SetActorHiddenInGame(!bShouldBeVisible);
            // Có thể thêm logic hiệu ứng, ví dụ:
            // if (!bShouldBeVisible) { TargetPlayer->PlayDisappearEffect(); }
            // else { TargetPlayer->PlayAppearEffect(); }
        }
        ```
    *   Lưu ý: Biến `bHidden` của `AActor` mặc định được replicate. Cách đơn giản nhất là Server gọi `TargetPlayer->SetActorHiddenInGame(!bShouldBeVisible);` trên Server. Sự thay đổi của `bHidden` sẽ tự động được replicate đến tất cả Client và mỗi Client sẽ tự động ẩn/hiện Actor đó trong thế giới cục bộ của mình. Sử dụng Client RPC như `Client_UpdatePlayerVisibility` là một cách khác nếu bạn cần thực hiện các hành động khác *chỉ* trên Client (ví dụ: phát hiệu ứng âm thanh/hình ảnh khi Actor xuất hiện/biến mất) hoặc nếu bạn không muốn dựa vào replication mặc định của `bHidden` vì lý do nào đó. Cách dùng replication `bHidden` đơn giản hơn cho người mới bắt đầu.

### Lớp Quản lý Phía Server (ví dụ: logic trong `AGameModeBase` hoặc `ABushVisibilityManager`)

*   Mục đích: Đây là bộ não của hệ thống bụi cỏ trên Server. Nó nhận thông báo từ các Character Player, theo dõi trạng thái, và thực thi logic hiển thị cho tất cả Client. Lớp này *chỉ tồn tại và chạy trên Server*.
*   Địa điểm:
    *   Option A (Đơn giản cho game nhỏ): Đặt logic trong `AGameModeBase` của bạn. `AGameModeBase` chỉ tồn tại trên Server và rất phù hợp để quản lý luật chơi và trạng thái tổng thể.
    *   Option B (Tốt hơn cho game phức tạp): Tạo một `ABushVisibilityManager` mới kế thừa từ `AActor`. Actor này chỉ được spawn ra trên Server (ví dụ: trong `AGameModeBase::PostLogin` hoặc `StartPlay`). Actor này cần được cấu hình `bNetTemporary = true;` và `bReplicates = false;` (nếu không cần replicate chính Manager Actor này, chỉ cần logic chạy trên Server). Cách này giúp tách biệt logic, làm code sạch sẽ và dễ quản lý hơn. Chúng ta sẽ đề xuất cách này.
*   Cấu trúc dữ liệu (trên Server): Cần lưu trữ thông tin người chơi nào đang ở trong bụi cỏ nào.
    *   `TMap<TWeakObjectPtr<ACustomPlayerCharacter>, TWeakObjectPtr<ABushActor>> PlayerToBushMap;`
        *   `PlayerToBushMap`: Map từ PlayerCharacter (tham chiếu yếu) đến BushActor (tham chiếu yếu) mà player đó đang ở trong. Nếu player không ở trong bụi cỏ nào, giá trị là `nullptr` hoặc không có trong map.
        *   Ưu điểm: Dễ dàng tìm bụi cỏ mà một player đang ở.
        *   Nhược điểm: Cần lặp qua map để tìm tất cả player trong một bụi cỏ cụ thể.
    *   `TMap<TWeakObjectPtr<ABushActor>, TArray<TWeakObjectPtr<ACustomPlayerCharacter>>> BushToPlayersMap;`
        *   `BushToPlayersMap`: Map từ BushActor (tham chiếu yếu) đến mảng các PlayerCharacter (tham chiếu yếu) đang ở trong bụi cỏ đó.
        *   Ưu điểm: Dễ dàng lấy danh sách tất cả player trong một bụi cỏ cụ thể.
        *   Nhược điểm: Cần lặp qua tất cả các bụi cỏ trong map để tìm bụi cỏ của một player cụ thể.
    *   Đề xuất: `PlayerToBushMap` thường đơn giản hơn để quản lý trạng thái cá nhân của từng player khi nhận thông báo vào/ra bụi cỏ. `BushToPlayersMap` thuận tiện hơn khi cần lặp qua tất cả player trong một bụi cỏ để áp dụng quy tắc hiển thị. Có thể dùng cả hai và đồng bộ chúng. Với logic hiển thị hiện tại (cần biết player A và player B có ở cùng bụi cỏ không), cả hai map đều dùng được. `PlayerToBushMap` có vẻ trực quan hơn cho logic xử lý va chạm từ từng player.
*   Logic chính (trên Server):
    *   Hàm xử lý khi Player báo cáo vào/ra bụi cỏ (được gọi từ `Server_ReportBushEntry`/`Exit` RPCs của Character):
        ```cpp
        // Trong ABushVisibilityManager.h:
        void HandlePlayerBushEntry(ACustomPlayerCharacter* Player, ABushActor* Bush);
        void HandlePlayerBushExit(ACustomPlayerCharacter* Player, ABushActor* Bush);

        // Trong ABushVisibilityManager.cpp:
        void ABushVisibilityManager::HandlePlayerBushEntry(ACustomPlayerCharacter* Player, ABushActor* Bush)
        {
            if (!IsValid(Player) || !IsValid(Bush)) return;
            PlayerToBushMap.Add(Player, Bush); // Cập nhật map trạng thái
            RecomputeVisibilityForAll(); // Kích hoạt logic tính toán lại hiển thị
        }

        void ABushVisibilityManager::HandlePlayerBushExit(ACustomPlayerCharacter* Player, ABushActor* Bush)
        {
            if (!IsValid(Player)) return; // Bush có thể đã bị hủy khi thoát
            // Chỉ xóa nếu player thực sự đang ở trong bụi cỏ đó (để tránh bug)
            TWeakObjectPtr<ABushActor>* CurrentBush = PlayerToBushMap.Find(Player);
            if (CurrentBush && CurrentBush->IsValid() && CurrentBush->Get() == Bush)
            {
                 PlayerToBushMap.Remove(Player); // Cập nhật map trạng thái
                 RecomputeVisibilityForAll(); // Kích hoạt logic tính toán lại hiển thị
            }
            // Xử lý trường hợp player bị Disconnect
            // GameModeBase::Logout() hoặc tương tự cần gọi RemovePlayer từ PlayerToBushMap
        }
        ```
    *   Hàm tính toán lại và áp dụng logic hiển thị cho tất cả người chơi:
        ```cpp
        // Trong ABushVisibilityManager.h:
        void RecomputeVisibilityForAll();

        // Trong ABushVisibilityManager.cpp:
        void ABushVisibilityManager::RecomputeVisibilityForAll()
        {
            // Lấy danh sách tất cả Player Controller và Player Character trên server
            UWorld* World = GetWorld();
            if (!World) return;

            TArray<APlayerController*> PlayerControllers;
            for (FConstPlayerControllerIterator Iterator = World->GetPlayerControllerIterator(); Iterator; ++Iterator)
            {
                if (APlayerController* PC = Iterator->Get())
                {
                    PlayerControllers.Add(PC);
                }
            }

            TArray<ACustomPlayerCharacter*> PlayerCharacters;
            for (TActorIterator<ACustomPlayerCharacter> ActorItr(World); ActorItr; ++ActorItr)
            {
                 PlayerCharacters.Add(*ActorItr);
            }

            // Lặp qua TẤT CẢ Player Controller (người quan sát)
            for (APlayerController* ObserverPC : PlayerControllers)
            {
                if (!IsValid(ObserverPC) || !ObserverPC->GetPawn()) continue;

                ACustomPlayerCharacter* ObserverCharacter = Cast<ACustomPlayerCharacter>(ObserverPC->GetPawn());
                 if (!IsValid(ObserverCharacter)) continue;

                // Lặp qua TẤT CẢ Player Character khác (mục tiêu)
                for (ACustomPlayerCharacter* TargetCharacter : PlayerCharacters)
                {
                    if (!IsValid(TargetCharacter) || TargetCharacter == ObserverCharacter) continue; // Không xét chính mình

                    // Áp dụng Luật Hiển Thị (chỉ trên Server)
                    bool bShouldTargetBeVisibleToObserver = ShouldTargetBeVisibleToObserver(ObserverCharacter, TargetCharacter);

                    // Ra lệnh cho Client của Observer ẩn/hiện Target
                    // Cách 1: Thay đổi bHidden trên Server (sẽ replicate)
                    // Hàm SetActorHiddenInGame được replicate, nên Server gọi là đủ.
                    TargetCharacter->SetActorHiddenInGame(!bShouldTargetBeVisibleToObserver);

                    // Cách 2: Gọi Client RPC (Nếu cần logic phức tạp hơn trên client)
                    // ObserverCharacter->Client_UpdatePlayerVisibility(TargetCharacter, bShouldTargetBeVisibleToObserver);
                    // LƯU Ý: Cách 2 phức tạp hơn vì cần đảm bảo PlayerCharacter Target tồn tại và hợp lệ trên Client của Observer
                    // và hàm Client_UpdatePlayerVisibility phải được gọi trên PlayerController của Observer,
                    // không phải Character của Observer. Cần một cơ chế gọi RPC từ Manager đến từng PlayerController.
                    // Cách 1 (SetActorHiddenInGame trên Server) đơn giản hơn nhiều cho người mới.
                }
            }
        }

        // Hàm quyết định hiển thị dựa trên trạng thái bụi cỏ
        bool ABushVisibilityManager::ShouldTargetBeVisibleToObserver(ACustomPlayerCharacter* Observer, ACustomPlayerCharacter* Target) const
        {
            // Quy tắc 4 (người chơi thấy chính mình) đã được xử lý ở vòng lặp RecomputeVisibilityForAll

            bool bObserverInBush = PlayerToBushMap.Contains(Observer);
            ABushActor* ObserverBush = bObserverInBush ? PlayerToBushMap[Observer].Get() : nullptr;

            bool bTargetInBush = PlayerToBushMap.Contains(Target);
            ABushActor* TargetBush = bTargetInBush ? PlayerToBushMap[Target].Get() : nullptr;

            // Quy tắc 3: Cả hai ngoài -> Hiện
            if (!bObserverInBush && !bTargetInBush)
            {
                return true;
            }

            // Quy tắc 1: Mục tiêu trong, Người quan sát ngoài -> Ẩn
            if (!bObserverInBush && bTargetInBush)
            {
                return false;
            }

            // Quy tắc 2: Cả hai trong CÙNG bụi cỏ -> Hiện
            if (bObserverInBush && bTargetInBush && ObserverBush == TargetBush)
            {
                 return true;
            }

            // Trường hợp còn lại:
            // - Observer trong bụi, Target ngoài: Hiện (người trong bụi vẫn thấy người ngoài)
            // - Observer trong bụi A, Target trong bụi B (khác A): Ẩn (người trong bụi chỉ thấy người trong CÙNG bụi)
            // Logic hiện tại: chỉ cần không rơi vào Quy tắc 1 và 2 thì mặc định ẩn.
            // Cần điều chỉnh nếu Quy tắc 3 và trường hợp Observer trong, Target ngoài là luôn hiện.
            // Diễn giải Quy tắc 1 ở trên bao hàm: Nếu Mục tiêu trong bụi, Người quan sát *bất kỳ ở ngoài* đều không thấy.
            // Điều này ngụ ý người trong bụi vẫn thấy người ngoài.
            // Diễn giải lại quy tắc cho rõ ràng hơn trong code:

            // Case 1: Target KHÔNG ở trong bụi nào
            if (!bTargetInBush)
            {
                return true; // Luôn hiện người không ở trong bụi
            }

            // Case 2: Target CÓ ở trong bụi
            {
                // Case 2a: Observer KHÔNG ở trong bụi nào
                if (!bObserverInBush)
                {
                    return false; // Người ngoài không thấy người trong bụi (Quy tắc 1)
                }
                // Case 2b: Observer CÓ ở trong bụi
                else // (bObserverInBush && bTargetInBush)
                {
                    // Kiểm tra xem họ có ở trong CÙNG bụi không
                    if (ObserverBush == TargetBush)
                    {
                        return true; // Người trong cùng bụi thấy nhau (Quy tắc 2)
                    }
                    else
                    {
                        return false; // Người trong bụi này không thấy người trong bụi khác (Suy diễn từ Q1 và Q2)
                    }
                }
            }

             // Logic fallback (không nên tới đây)
             return false;
        }
        ```

## 4. Luồng Logic và Thuật Toán Xử Lý (Chi tiết)

Đây là trình tự các sự kiện và xử lý khi một người chơi tương tác với bụi cỏ:

1.  Client: Phát hiện Va chạm:
    *   Character (`ACustomPlayerCharacter`) trên Client (local client) di chuyển.
    *   Component va chạm của Character (ví dụ: CapsuleComponent) overlap với `BushOverlapVolume` của một `ABushActor`.
    *   Unreal Engine kích hoạt sự kiện `OnComponentBeginOverlap` hoặc `OnComponentEndOverlap` trên Client.

2.  Client: Báo cáo lên Server:
    *   Hàm xử lý va chạm trên Client của Character (`OnOverlapBegin`/`End` của Character's Capsule) được gọi.
    *   Trong hàm này, kiểm tra xem `OtherActor` có phải là `ABushActor` không và có phải là client đang điều khiển Character này (`IsLocallyControlled()`) không.
    *   Nếu đúng, Client gọi Server RPC tương ứng: `Server_ReportBushEntry(Cast<ABushActor>(OtherActor));` hoặc `Server_ReportBushExit(Cast<ABushActor>(OtherActor));`.
    *   > Lý do Client báo cáo: Client có thông tin va chạm tức thời. Việc client báo cáo giúp server phản ứng nhanh với hành động di chuyển của người chơi. Tuy nhiên, server vẫn là nơi quyết định cuối cùng và có thể xác minh lại nếu cần.

3.  Server: Xử lý Báo cáo RPC:
    *   Server nhận và thực thi hàm `Server_ReportBushEntry` hoặc `Server_ReportBushExit` trên Character của người chơi gửi RPC.
    *   Trong hàm này, Server gọi logic quản lý hiển thị (ví dụ: trên `ABushVisibilityManager`) để xử lý sự kiện: `HandlePlayerBushEntry(...)` hoặc `HandlePlayerBushExit(...)`.
    *   Logic quản lý trên Server cập nhật trạng thái nội bộ (`PlayerToBushMap`).

4.  Server: Tính toán lại Logic Hiển thị:
    *   Sau khi cập nhật trạng thái, Server gọi hàm `RecomputeVisibilityForAll()`.
    *   Hàm này lặp qua *tất cả* các `APlayerController` hiện có (đại diện cho các người chơi đang kết nối).
    *   Với mỗi `ObserverPlayerController`, nó lặp qua *tất cả* các `ACustomPlayerCharacter` khác trong game (`TargetCharacter`).
    *   Đối với mỗi cặp (Observer, Target), Server áp dụng hàm `ShouldTargetBeVisibleToObserver(...)` dựa trên trạng thái "trong bụi cỏ" của cả hai (lấy từ `PlayerToBushMap`).
    *   Kết quả là một giá trị boolean cho biết `Observer` có nên thấy `Target` không.

5.  Server: Ra lệnh Cập nhật Hiển thị trên Client:
    *   Dựa trên kết quả tính toán ở bước 4, nếu trạng thái hiển thị của `TargetCharacter` đối với `ObserverPlayerController` cần thay đổi (ví dụ: trước đó ẩn, giờ cần hiện; hoặc trước đó hiện, giờ cần ẩn), Server ra lệnh cho Client của `ObserverPlayerController` cập nhật hiển thị của Actor `TargetCharacter`.
    *   Cách thực hiện (được đề xuất cho người mới): Server gọi `TargetCharacter->SetActorHiddenInGame(!bShouldTargetBeVisibleToObserver);` trên Server. Vì `bHidden` của `AActor` được replicate mặc định, sự thay đổi này sẽ được replicate đến tất cả các Client. Mỗi Client nhận giá trị `bHidden` mới cho Actor `TargetCharacter` và tự động cập nhật trạng thái ẩn/hiện cục bộ của Actor đó.
    *   > Lưu ý: Mặc dù `SetActorHiddenInGame` trên Server replicate đến *tất cả* client, nhưng mỗi client chỉ có bản sao của Actor `TargetCharacter` trong thế giới game cục bộ của riêng họ. Do đó, việc ẩn/hiện chỉ ảnh hưởng đến cách Actor đó được render trên từng client, không ảnh hưởng đến các client khác. Server là nơi duy nhất kiểm soát giá trị `bHidden` authoritative.

6.  Client: Cập nhật Hiển thị cục bộ:
    *   Client nhận bản replicate mới của biến `bHidden` cho Actor `TargetCharacter` từ Server.
    *   Unreal Engine tự động xử lý việc này, cập nhật cờ `bHidden` trên Actor `TargetCharacter` của Client.
    *   Hệ thống rendering của Client tôn trọng cờ `bHidden` và ẩn hoặc hiện Actor `TargetCharacter` một cách phù hợp.

Sơ đồ khối (Flowchart):

```svg
<svg width="900" height="700" xmlns="http://www.w3.org/2000/svg">
  <style>
    .node {
      stroke: #333;
      stroke-width: 1.5;
      font-family: Arial;
      font-size: 14px;
    }
    .process { fill: #2196F3; } /* Blue */
    .data { fill: #4CAF50; } /* Green */
    .decision { fill: #ff9800; } /* Orange */
    .io { fill: #FFEB3B; } /* Yellow */
    .server-label { fill: #B71C1C; font-weight: bold; } /* Dark Red */
    .client-label { fill: #1A237E; font-weight: bold; } /* Dark Blue */
    .edge { stroke: #333; stroke-width: 1.5; marker-end: url(#arrowhead); }
    .label { font-size: 12px; fill: #555; text-anchor: middle; }
     #arrowhead path { fill: #333; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" />
    </marker>
  </defs>

  <!-- Swimlanes -->
  <line x1="450" y1="0" x2="450" y2="700" stroke="#ccc" stroke-width="2"/>
  <text x="225" y="20" text-anchor="middle" class="client-label">CLIENT</text>
  <text x="675" y="20" text-anchor="middle" class="server-label">SERVER</text>

  <!-- Nodes -->
  <!-- Client Side -->
  <rect x="50" y="50" width="350" height="50" rx="5" ry="5" class="process"/>
  <text x="225" y="80" class="node" text-anchor="middle">Client: Phát hiện Overlap (Character & BushActor)</text>

  <rect x="100" y="130" width="250" height="50" rx="5" ry="5" class="decision"/>
  <text x="225" y="160" class="node" text-anchor="middle">Client: Là Player Character của tôi?</text>

  <rect x="150" y="210" width="150" height="50" rx="5" ry="5" class="process"/>
  <text x="225" y="240" class="node" text-anchor="middle">Client: Gọi Server RPC</text>
  <text x="225" y="260" class="label" text-anchor="middle">(Server_ReportBushEntry/Exit)</text>

  <rect x="50" y="600" width="350" height="50" rx="5" ry="5" class="process"/>
  <text x="225" y="630" class="node" text-anchor="middle">Client: Cập nhật Hiển thị Actor cục bộ (qua replication bHidden)</text>


  <!-- Server Side -->
  <rect x="500" y="290" width="350" height="50" rx="5" ry="5" class="io"/>
  <text x="675" y="320" class="node" text-anchor="middle">Server: Nhận Server RPC từ Client</text>

  <rect x="550" y="370" width="250" height="50" rx="5" ry="5" class="process"/>
  <text x="675" y="400" class="node" text-anchor="middle">Server: Cập nhật Trạng thái Player (trong Bush Manager)</text>
  <text x="675" y="420" class="label" text-anchor="middle">(PlayerToBushMap)</text>

  <rect x="500" y="450" width="350" height="50" rx="5" ry="5" class="process"/>
  <text x="675" y="480" class="node" text-anchor="middle">Server: Tính toán lại Hiển thị cho TẤT CẢ Player Controllers/Characters</text>
  <text x="675" y="500" class="label" text-anchor="middle">(Hàm RecomputeVisibilityForAll)</text>

  <rect x="500" y="530" width="350" height="50" rx="5" ry="5" class="process"/>
  <text x="675" y="560" class="node" text-anchor="middle">Server: Ra lệnh Ẩn/Hiện Target Actor trên Server</text>
  <text x="675" y="580" class="label" text-anchor="middle">(TargetCharacter->SetActorHiddenInGame)</text>


  <!-- Edges -->
  <path d="M225 100 V 130" class="edge"/>
  <path d="M225 180 V 210" class="edge"/>
  <path d="M300 235 H 500" class="edge"/> <!-- Client RPC to Server -->
    <text x="400" y="245" class="label" text-anchor="middle">Server RPC</text>

  <path d="M675 340 V 370" class="edge"/>
  <path d="M675 420 V 450" class="edge"/>
  <path d="M675 500 V 530" class="edge"/>
  <path d="M500 555 H 400" class="edge"/> <!-- Replication from Server to Client -->
    <text x="450" y="565" class="label" text-anchor="middle">Replication (bHidden)</text>

  <path d="M200 160 H 50" class="edge" stroke-dasharray="5,5"/>
  <text x="125" y="150" class="label" text-anchor="middle">Không phải -> Bỏ qua</text>


</svg>
```

## 5. Quản lý Trạng thái Hiển thị

Unreal Engine cung cấp hai cách chính để kiểm soát hiển thị Actor trong multiplayer:

1.  Thay đổi trạng thái ẩn/hiện trên Server (`SetActorHiddenInGame`) và dựa vào Replication:
    *   Như đã đề cập, biến `bHidden` của `AActor` là một biến được replicate mặc định.
    *   Nếu một `AActor` được cấu hình replication (`bReplicates = true`), khi Server thay đổi giá trị `bHidden` của Actor đó bằng cách gọi `SetActorHiddenInGame()`, sự thay đổi này sẽ được tự động gửi đến tất cả các Client đã replicate Actor đó.
    *   Mỗi Client nhận giá trị `bHidden` mới và cập nhật trạng thái hiển thị cục bộ của Actor đó trong thế giới game của họ.
    *   `AActor::SetActorHiddenInGame` thường gọi `OnRep_bHidden` trên Client khi giá trị replicate thay đổi.

2.  Hệ thống Actor relevancy (`AActor::IsNetRelevantFor`, `ForceNetUpdate`):
    *   Mỗi `APlayerController` có một tập các Actor mà Server quyết định là "relevant" (liên quan) đối với Client của PlayerController đó. Server chỉ replicate Actor và các biến được replicate của nó đến những Client mà nó relevant.
    *   Mặc định, một Actor thường relevant nếu nó ở gần Character của Player Controller đó hoặc nếu nó là Character của Player Controller khác.
    *   Bạn có thể override `AActor::IsNetRelevantFor(const APlayerController* ForRemotePC)` trên Actor của mình để định nghĩa logic relevancy tùy chỉnh. Server sẽ gọi hàm này cho mỗi cặp (Actor, PlayerController) để quyết định có replicate Actor đó cho Client của PlayerController đó không.
    *   Nếu một Actor không relevant cho một Client, Client đó sẽ không có bản sao của Actor đó hoặc Actor sẽ bị ẩn.

Đề xuất phương pháp cho người mới bắt đầu:

Phương pháp 1 (Thay đổi `bHidden` trên Server và dựa vào Replication) được đề xuất cho người mới bắt đầu vì:
*   Đơn giản hơn: Nó dựa trên cơ chế replication biến đã có sẵn và dễ hiểu. Bạn chỉ cần thay đổi một cờ trên Server và Unreal Engine lo phần còn lại của việc đồng bộ hóa đến Client.
*   Kiểm soát hiển thị trực tiếp: `SetActorHiddenInGame` là một cách rõ ràng để điều khiển việc render. Bạn ra lệnh ẩn/hiện và Actor biến mất/xuất hiện.

Phương pháp 2 (Actor relevancy) là một tối ưu hóa nâng cao hơn:
*   Hiệu quả mạng hơn: Nếu một Actor hoàn toàn không relevant, Server sẽ không gửi bất kỳ dữ liệu replicate nào về nó đến Client đó, tiết kiệm băng thông. Với phương pháp 1, Actor vẫn được replicate, chỉ là cờ `bHidden` được gửi đi.
*   Phức tạp hơn để tùy chỉnh: Override `IsNetRelevantFor` đòi hỏi hiểu biết sâu hơn về cơ chế replication và có thể phức tạp để xử lý các trường hợp biên, đặc biệt khi logic relevancy phụ thuộc vào trạng thái phức tạp (như ở trong bụi cỏ nào).

Đối với tính năng bụi cỏ, việc sử dụng `SetActorHiddenInGame(!bShouldBeVisible)` trên Server cho `TargetCharacter` là cách hiệu quả và đủ đơn giản để đạt được hiệu ứng mong muốn và phù hợp với luồng logic đã thiết kế.

## 6. Giải thích Lựa chọn Thiết kế ('Tại sao làm vậy?')

*   Tại sao cần RPCs để giao tiếp Client-Server?
    *   Client cần thông báo cho Server về các hành động hoặc sự kiện xảy ra cục bộ (ví dụ: người chơi di chuyển vào/ra vùng va chạm bụi cỏ). Server RPC (`Server_ReportBushEntry`/`Exit`) là cách tiêu chuẩn và an toàn trong Unreal Engine để Client gửi yêu cầu thực hiện một hàm trên Server.
    *   Server cần ra lệnh cho Client thực hiện một hành động hoặc cập nhật trạng thái hiển thị. Client RPC (`Client_UpdatePlayerVisibility`) cho phép Server gọi một hàm cụ thể trên một Client cụ thể.
    *   Việc sử dụng RPCs đảm bảo rằng giao tiếp giữa Client và Server tuân thủ mô hình mạng của Engine, giúp quản lý đồng bộ hóa và xử lý các vấn đề mạng (như độ trễ) tốt hơn so với việc cố gắng tự gửi gói tin raw.
*   Tại sao Server phải là nơi authoritative cho trạng thái 'trong bụi cỏ' và logic hiển thị?
    *   Chống gian lận: Nếu Client tự quyết định trạng thái "trong bụi cỏ" của mình hoặc người khác và logic hiển thị, Client gian lận có thể bỏ qua các quy tắc này (ví dụ: luôn báo cáo là đang ngoài bụi cỏ hoặc luôn thấy tất cả mọi người). Server là nguồn đáng tin cậy duy nhất, đảm bảo mọi Client đều tuân theo cùng một luật chơi.
    *   Tính nhất quán: Server có cái nhìn toàn cục và chính xác nhất về trạng thái của tất cả người chơi và tất cả các bụi cỏ. Chỉ Server mới có đủ thông tin để áp dụng chính xác các quy tắc hiển thị cho mọi cặp (người quan sát, mục tiêu) trên tất cả các Client một cách nhất quán.
    *   Xử lý độ trễ: Mặc dù Client có thể có dự đoán cục bộ để phản hồi nhanh hơn, quyết định cuối cùng của Server giúp giải quyết sự không đồng bộ tạm thời do độ trễ mạng.
*   Ưu/nhược điểm của việc Client thông báo va chạm so với Server tự phát hiện va chạm:
    *   Client thông báo (đã chọn):
        *   Ưu điểm: Phản ứng nhanh với hành động di chuyển của người chơi. Logic va chạm của Character đã có sẵn trên Client. Giảm tải cho Server trong việc chạy mô phỏng va chạm chi tiết cho mọi thứ.
        *   Nhược điểm: Dễ bị gian lận (client có thể không gửi RPC hoặc gửi sai thông tin). Server cần xác minh hoặc ít nhất là tin tưởng vào thông báo ban đầu của Client.
    *   Server tự phát hiện va chạm:
        *   Ưu điểm: Hoàn toàn đáng tin cậy, không thể bị gian lận từ phía Client (liên quan đến việc báo cáo va chạm).
        *   Nhược điểm: Server cần chạy mô phỏng va chạm cho tất cả Player Character và tất cả BushActor một cách hiệu quả. Có thể có độ trễ lớn hơn giữa hành động di chuyển của người chơi trên Client và việc Server phát hiện va chạm, dẫn đến cảm giác không nhạy. Việc thiết lập component va chạm của Character để replicate và xử lý va chạm chỉ trên Server có thể phức tạp hơn.
    *   Lý do lựa chọn Client báo cáo: Với các game hành động nhịp độ nhanh, phản hồi tức thời khi vào bụi cỏ là quan trọng cho trải nghiệm người chơi. Việc Client báo cáo là sự đánh đổi hợp lý giữa hiệu năng, độ trễ và độ tin cậy. Cơ chế Server authoritative ở các bước sau (cập nhật trạng thái và quyết định hiển thị) là đủ để chống lại hầu hết các hình thức gian lận liên quan đến va chạm này.
*   Làm thế nào thiết kế này đảm bảo tính nhất quán trên các Client và tránh gian lận?
    *   Nhất quán: Server là nguồn quyết định duy nhất cho trạng thái "trong bụi cỏ" và logic hiển thị. Mọi Client đều nhận lệnh ẩn/hiện từ cùng một nguồn đáng tin cậy (Server) dựa trên cùng một trạng thái game và cùng một bộ quy tắc. Mặc dù độ trễ mạng có thể khiến các Client nhận lệnh ở các thời điểm hơi khác nhau, trạng thái cuối cùng mà họ hiển thị sẽ luôn phù hợp với quyết định của Server.
    *   Chống gian lận:
        *   Client không tự quyết định trạng thái ẩn/hiện của người chơi khác. Lệnh này hoàn toàn đến từ Server. Một Client gian lận không thể tự ý hiển thị những người chơi mà Server đã ra lệnh ẩn.
        *   Client báo cáo va chạm có thể bị giả mạo, nhưng Server Manager có thể thêm bước xác minh cơ bản (ví dụ: kiểm tra xem Character của người chơi báo cáo có thực sự overlap với BushActor đó trên Server tại thời điểm nhận RPC hay không). Tuy nhiên, việc xác minh va chạm trên Server có thể phức tạp và tốn hiệu năng. Quan trọng nhất là Client không thể bypass logic hiển thị được kiểm soát bởi Server. Kẻ gian lận có thể cố gắng để Server nghĩ họ ở trong bụi cỏ khi họ không, nhưng họ không thể khiến Server ra lệnh cho Client khác thấy họ khi lẽ ra phải ẩn.

Thiết kế này tập trung vào việc giao quyền quyết định quan trọng nhất (ai thấy ai) cho Server, đồng thời tận dụng khả năng phát hiện va chạm ban đầu của Client để có phản hồi nhanh hơn.